# Translation

This document summarizes the phases that C source files go through during translation from source files to an executable program.

**NOTE:** Translation occurs *as if* each of these phases took place independently. The exact compiler behaviour is implementation specific and may differ slightly.

## Phase 1: Map Bytes to Source Character Set

Source files may differ in how the characters are represented or which characters are present depending on the operating system and editor used. This phase translates the wide range of possible characters to a standard set, oftentimes ASCII.

The only requirement for the source character set is that it must at a minimum contain 96 core characters:
* The 26 lower case English letters
* The 26 upper case English letters
* The 10 digits
* The following 29 punctuation characters:
  * `_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '`
* The following 5 whitespace characters:
  * Space, horizontal tab, vertical tab, form feed, new line

### 1.1: Map Individual Bytes

The individual characters of the source code (usually encoded using a multibyte system such as UTF-8) are converted to single-byte characters from the source character set.

### 1.2: Map Trigraphs

Trigraph sequences are replaced by their corresponding single-character representations.

## Phase 2: Merge Source Lines

All lines that end with a backslash (`\ `) followed by a newline character have both the backslash and newline character deleted, merging the current line of source code with the following one. If after this phase the source file does not end with a newline character, the behaviour of the compiler is undefined.

## Phase 3: Tokenization

During this phase, the source file is decomposed from a single block of continuous text into discrete tokens. Tokens are formed using the "maximal munch" rule (a greedy algorithm): the next token is formed by taking the longest sequence of characters which could constitute another preprocessing token.

### 3.1 Form Tokens

The source file is decomposed into a sequence of tokens. The possible types of tokens are:
* Whitespace sequence
* Newline
* Comment block
* Preprocessing token
  * Header names (e.g. `<stdio.h>`, `"myHeader.h"`, etc.)
  * Preprocessing numbers
    * Integer constants (e.g. `36`, `044u`, `0x24ll`, etc.)
    * Floating-point constants (e.g. `1.0`, `.1`, `1.`, `1.8e1`, `0x1.2p4`, etc.)
  * Character constants (e.g. `'a'`, `'!'`, `'\n'`, etc.)
  * String literals (e.g. `"abc"`, `"\x1a = 26"`, `"Áå´üçå"`, etc.)
  * Operators (e.g. `+`, `-`, `<=`, `?`, `<<`, etc.)
  * Punctuators (e.g. `=`, `[`, `]`, `,`, `#`, `##`, etc.)
  * Identifiers (e.g. `int`, `my_val`, `_CONSTANT`, `üê±`, etc.)
  * Any single non-whitespace character which does not fit into the above categories

### 3.2 Replace Comments

All comment blocks are replaced by a single space character (` `).

### 3.3 Condense whitespace

Compilers may choose to replace each whitespace sequence token with a single space character (` `).

## Phase 4: Preprocessing

During preprocessing, a set of preprocessor directives can be used to perform metaprogramming functions. The preprocessor directives allow insertion and/or deletion of code, as well as some error checking and sometimes minor changes to compiler settings.

All preprocessor directives are executed. Any new code inserted using the `#include` directive goes through the previous three phases. All preprocessor directives are removed after execution.

## Phase 5: Map Escape Sequences to Execution Character Set

Escape sequenced characters within character constants and string literals are converted to characters in the execution character set.

The execution character set can differ from the source character set. Most of the time, however, the execution character set is either identical to the source character set, or a superset of it. Note that the execution character set does not need to be a single-byte character set like the source character set: it can be a multibyte character set.

## Phase 6: Concatenate Strings

Adjacent string literals and those separated only by a whitespace sequence are concatenated.

## Phase 7: Compilation

The remaining tokens are analyzed for correct syntax and semantics, then converted into assembly instructions for the specific processor architecture that the program will run on.

## Phase 8: Assembly

The machine instructions generated by the compilation phase are converted into actual machine code instructions for the intended processor.

## Phase 9: Linking

The output of the assembly phase is multiple "object" files which contain the machine instructions for various files/libraries. These files need to be "linked" into a single file which contains all of the code in one self-contained location. This is the final phase of translation.